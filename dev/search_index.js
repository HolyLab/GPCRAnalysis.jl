var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = GPCRAnalysis","category":"page"},{"location":"#GPCRAnalysis","page":"Home","title":"GPCRAnalysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GPCRAnalysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GPCRAnalysis]","category":"page"},{"location":"#GPCRAnalysis.AAProperties","page":"Home","title":"GPCRAnalysis.AAProperties","text":"AAProperties\n\nA 3-vector (similar to SVector{3,Float64}) that can also be accessed by fields charge, hydropathy, and volume:\n\nFor standard amino acids, charge is -1, 0, or 1, with the exception of histidine, which is assigned a charge of 0.1 (assuming pH 7.4).\nhydropathy is the Kyte-Doolittle hydropathy index. See Kyte J, Doolittle RF (May 1982). \"A simple method for displaying the hydropathic character of a protein\". Journal of Molecular Biology. 157 (1): 105–132.\nvolume is the van der Waals volume in cubic Angstroms (Å³).\n\n\n\n\n\n","category":"type"},{"location":"#GPCRAnalysis.AccessionCode","page":"Home","title":"GPCRAnalysis.AccessionCode","text":"ac = AccessionCode(msa, seqname)\n\nReturn the Uniprot accession code associated with seqname.\n\n\n\n\n\n","category":"type"},{"location":"#GPCRAnalysis.BWScheme-Tuple{AbstractVector, AbstractVector}","page":"Home","title":"GPCRAnalysis.BWScheme","text":"BWScheme(conserved_idx, tmspans)\n\nSpecify the Ballesteros-Weinstein scheme used for a particular protein. conserved_idx is a list of 7 \"most conserved\" residues per helix (rhodopsin family: N1, D2, R3, W4, P5, P6, P7) and the span of each helix.\n\nExamples\n\nFor mouse rhodopsin (P15409),\n\njulia> opsd_scheme = BWScheme([55, 83, 135, 161, 215, 267, 303],\n                              [37:61, 74:96, 111:133, 153:173, 203:224, 253:274, 287:308]);\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.MSACode","page":"Home","title":"GPCRAnalysis.MSACode","text":"mc = MSACode(msa, accession)\n\nReturn the MSA-internal sequence name associated with accession.\n\n\n\n\n\n","category":"type"},{"location":"#GPCRAnalysis.NWGapCosts-Union{Tuple{}, Tuple{T}} where T","page":"Home","title":"GPCRAnalysis.NWGapCosts","text":"gapcosts = NWGapCosts{T}(; extend1=0, extend2=0, open1=0, open2=0)\n\nCreate an affine cost for gaps in Needleman-Wunsch alignment. The cost of a gap of length k is\n\nextend * k + open\n\nAll costs must be nonnegative.\n\ngapcosts(ϕ, idxs1, idxs2) computes the contribution of gaps to the cost of alignment ϕ between two sequences with idxs1 = eachindex(seq1) and idxs2 = eachindex(seq2). (The indices are needed to determine whether the alignment starts or ends with a gap.)\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.SequenceMapping","page":"Home","title":"GPCRAnalysis.SequenceMapping","text":"sm = SequenceMapping([4, 5, 0, ...])\nsm = SequenceMapping(seq::AnnotatedAlignedSequence)\n\nA SequenceMapping is a vector of indexes within a full sequence that map to a reference. Specifically, sm[i] is the index of the residue in the full sequence that maps to the i-th position in the reference. 0 is a placeholder for a position in the reference that has no mapping to the full sequence.\n\nExample\n\nSequenceMapping([4, 5, 0, ...]) indicates that:\n\nthe first position in the reference maps to the fourth residue in the full sequence,\nthe second position in the reference maps to the fifth residue in the full sequence, and\nthe third position in the reference lacks a corresponding residue in the full sequence.\n\n\n\n\n\n","category":"type"},{"location":"#GPCRAnalysis.StructAlign-Tuple{Union{BioStructures.Chain, AbstractVector{<:BioStructures.AbstractResidue}}, Union{BioStructures.Chain, AbstractVector{<:BioStructures.AbstractResidue}}, AbstractString}","page":"Home","title":"GPCRAnalysis.StructAlign","text":"StructAlign(struct1::ChainLike, struct2::ChainLike, filename::AbstractString)\n\nCreate a structure-based alignment between struct1 and struct2. filename is the name of the TM-align \"results\" file (e.g., https://zhanggroup.org//TM-align/example/873772.html).\n\nSee also residueindex.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.aa_properties_matrix-Tuple{Any}","page":"Home","title":"GPCRAnalysis.aa_properties_matrix","text":"P = aa_properties_matrix(msa)\n\nReturn a matrix of z-scored biophysical properties (see AAProperties, but note that the scaling and interpretation is altered by z-scoring) for each residue in the MSA. P is a matrix-of-vectors.\n\nP[i, j] is the property-vector of the ith residue (in MSA indexing) of the jth sequence. Note this is transposed relative to the standard MSA matrix. Transposition facilitates \"flattening\" the property-vectors along the first axis using reinterpret.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.align-Tuple{AbstractMatrix{Float64}, Union{BioStructures.Chain, BioStructures.Model, BioStructures.MolecularStructure, AbstractVector{<:BioStructures.AbstractResidue}}, SequenceMapping}","page":"Home","title":"GPCRAnalysis.align","text":"tform = align(fixedpos::AbstractMatrix{Float64}, moving::Chain, sm::SequenceMapping)\ntform = align(fixed::Chain, moving::Chain, sm::SequenceMapping)\n\nReturn a rotated and shifted version of moving so that the centroids of residues moving[sm] have least mean square error deviation from positions fixedpos or those of residues fixed. fixed or fixedpos should include just the residues or positions you want to align to, but moving should be an entire chain.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.align_closest-Tuple{Any, Any}","page":"Home","title":"GPCRAnalysis.align_closest","text":"tform = align_closest(mapto::StructLike, mapfrom::StructLike; Dthresh=5)\ntform = align_closest(coordsto, coordsfrom; Dthresh=5)\n\nReturn the rigid transformation best aligning mapfrom to mapto. The transformation is computed from residues matched by map_closest, using only residues closer than Dthresh.\n\nBecause the mapping is determined by distance, this can only \"tweak\" an already-close alignment.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.align_nw-Tuple{AbstractMatrix, NWGapCosts}","page":"Home","title":"GPCRAnalysis.align_nw","text":"ϕ = align_nw(D, gapcosts::NWGapCosts)\n\nGiven a pairwise penalty matrix D (e.g., a pairwise distance matrix) and costs for opening and extending gaps, find the optimal pairings\n\nϕ = [(i1, j1), (i2, j2), ...]\n\nthat minimize\n\nsum(D[ϕk...] for ϕk in ϕ) + gapcosts(ϕ, axes(D)...)\n\nsubject to the constraint that all(ϕ[k+1] .> ϕ[k]) for all k.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.align_nw-Tuple{Union{BioStructures.Chain, AbstractVector{<:BioStructures.AbstractResidue}}, Union{BioStructures.Chain, AbstractVector{<:BioStructures.AbstractResidue}}, NWGapCosts}","page":"Home","title":"GPCRAnalysis.align_nw","text":"ϕ = align_nw(seq1, seq2, gapcosts::NWGapCosts; mode=:distance_orientation)\n\nFind the optimal ϕ matching seq1[ϕ[k][1]] to seq2[ϕ[k][2]] for all k. mode controls the computation of pairwise matching penalties, and can be either :distance or :distance_orientation, where the latter adds any mismatch in sidechain orientation to the distance penalty.\n\nseq1 and seq2 must be aligned to each other in 3D space before calling this function. See align.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.align_ranges-Tuple{Union{BioStructures.Chain, AbstractVector{<:BioStructures.AbstractResidue}}, AbstractVector{<:BioStructures.AbstractResidue}, AbstractVector{<:AbstractUnitRange}}","page":"Home","title":"GPCRAnalysis.align_ranges","text":"seqtms = align_ranges(seq1, seq2, seq2ranges::AbstractVector{<:AbstractUnitRange})\n\nTransfer seq2ranges, a list of reside index spans in seq2, to seq1. seq1 and seq2 must be spatially aligned, and the assignment is made by minimizing inter-chain distance subject to the constraint of preserving sequence order.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.align_to_axes-Tuple{Any}","page":"Home","title":"GPCRAnalysis.align_to_axes","text":"tform = align_to_axes(strct)\n\nCompute the transformation needed to align the principle axes of inertia of strct with the coordinate axes.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.align_to_membrane-Tuple{Union{BioStructures.Chain, AbstractVector{<:BioStructures.AbstractResidue}}, Any}","page":"Home","title":"GPCRAnalysis.align_to_membrane","text":"tform = align_to_membrane(chain::ChainLike, tms; extracellular=true)\n\nCompute the rigid transformation tform needed to align chain to the membrane, given the transmembrane segments tms as residue-indexes (e.g., [37:61, 74:96, ...]). extracelluar should be true if the N-terminus of the protein is extracellular (chain[first(tms[1])] is at the extracellular face), and false otherwise.\n\napplytransform!(chain, tform) (or the model that includes chain) will re-orient chain so that the center of the membrane is z=0 and extracellular is positive. Moreover, the mean x and y position of atoms in the transmembrane residues will be zero.\n\nThe algorithm finds the membrane normal u by maximizing the ratio\n\nΣᵢ (u ⋅ vᵢ)²\n------------\nΣᵢ (u ⋅ δᵢ)²\n\nwhere vᵢ is a vector parallel to the ith TM helix, and δᵢ is a within-leaflet atomic displacement.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.alphacarbon_coordinates-Tuple{Any}","page":"Home","title":"GPCRAnalysis.alphacarbon_coordinates","text":"alphacarbon_coordinates(res::AbstractResidue)\n\nReturn the coordinates of the α-carbon in res.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.alphacarbon_coordinates_matrix-Tuple{Any}","page":"Home","title":"GPCRAnalysis.alphacarbon_coordinates_matrix","text":"alphacarbon_coordinates_matrix(seq)\n\nReturn a matrix of αC coordinates as columns across all residues. See also alphacarbon_coordinates.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.alphafoldfile","page":"Home","title":"GPCRAnalysis.alphafoldfile","text":"fns = alphafoldfile(uniprotXname, dirname=pwd(); join=false)\n\nReturn the latest version of the AlphaFold file for uniprotXname in dirname. If join is true, then the full path is returned.\n\n\n\n\n\n","category":"function"},{"location":"#GPCRAnalysis.alphafoldfiles","page":"Home","title":"GPCRAnalysis.alphafoldfiles","text":"msacode2structfile = alphafoldfiles(msa, dirname=pwd())\n\nReturn a dictionary mapping MSACodes to the corresponding AlphaFold structure files.\n\n\n\n\n\n","category":"function"},{"location":"#GPCRAnalysis.alphafoldfiles-2","page":"Home","title":"GPCRAnalysis.alphafoldfiles","text":"fns = alphafoldfiles(dirname=pwd(); join=false)\n\nReturn the latest version of all AlphaFold files in dirname. If join is true, then the full paths are returned.\n\n\n\n\n\n","category":"function"},{"location":"#GPCRAnalysis.chargelocations-Tuple{Union{BioStructures.Chain, AbstractVector{<:BioStructures.AbstractResidue}}}","page":"Home","title":"GPCRAnalysis.chargelocations","text":"chargelocations(chain::ChainLike; include_his::Bool=false)\n\nReturn a list of potential charge locations in the protein structure. Each is a tuple (position, residueindex, AAname). The positions are those of N (in positively-charged residues like Arg & Lys) or O (in negatively-charged residues like Asp and Glu). N- and C-termini are not included in the list. While each residue will carry a net total charge of ±1, the location of each potential charge will be listed (1 for Lys, 2 each for Arg, Asp, and Glu).\n\nBy default, histidine is not considered charged, but you can include it by setting include_His=true.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.chimerax_script-NTuple{4, Any}","page":"Home","title":"GPCRAnalysis.chimerax_script","text":"chimerax_script(scriptfilename, uprot_list, msa, colidxs;\n                dir=pwd(), align=true, chain_transparency=80, styles=Dict{Int,String}(), extras=String[])\n\nCreate a chimerax visualization script with name scriptfilename. uprot_list is a list of UniProtX names that you want to visualize. msa is a Multiple Sequence alignment and colidxs specifies the column indices in msa corresponding to amino acid side chains that you'd like to visualize.\n\nKeyword arguments:\n\ndir is the directory with the protein structure files\nalign determines whether to align the structures to the first one (uses the matchmaker tool)\nchain_transparency sets the transparency on the ribbon diagrams (0 = not\n\ntransparent)\n\nstyles can be used to affect the display, e.g., Dict(k => \"@SD sphere\")\n\nwould cause methionines at column index k to be displayed with the sulfur in sphere mode.\n\nextras can be used to hand-specify a number of additional commands; this can\n\nbe useful if, for example, the msa has occasional misalignments.\n\nExamples\n\nSuppose you have the msa for rhodopsin (mouse: P15409), then:\n\nchimerax_script(\"myscript.cxc\", [\"P15409\"], msa, [i1, i2, i3])\n\nwhere i1 through i3 are column-indices in the msa that you'd like to view.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.columnindexes","page":"Home","title":"GPCRAnalysis.columnindexes","text":"idxs = columnindexes(msa)\n\nReturn the indices of the conserved columns of the MSA.\n\n\n\n\n\n","category":"function"},{"location":"#GPCRAnalysis.columnwise_entropy-Tuple{Any, Any}","page":"Home","title":"GPCRAnalysis.columnwise_entropy","text":"columnwise_entropy(f, msa)\n\nCompute the entropy of each column in an MSA, after applying f to each residue. Low entropy indicates high conservation.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.download_alphafolds-Tuple{Any}","page":"Home","title":"GPCRAnalysis.download_alphafolds","text":"download_alphafolds(msa; dirname=pwd())\ndownload_alphafolds(ids; dirname=pwd())\n\nDownload all available AlphaFold structures for the sequences in msa. Missing entries are silently skipped.\n\nIf an msa is provided, each downloaded PDB file is checked to ensure that the residues in the MSA sequence match those in the PDB file. If they do not match, the PDB file is removed.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.features_from_structure","page":"Home","title":"GPCRAnalysis.features_from_structure","text":"mgmm = features_from_structure(seq::ChainLike, idxs=1:length(seq); combined=false)\n\nConstruct an IsotropicMultiGMM from seq by adding features for each residue in idxs.\n\ncombined=true causes all atoms sharing the same feature to be combined, reducing the total number of features in the resulting model. The default creates features for each atom separately.\n\nThe σfun and ϕfun keyword arguments are functions that determine the standard deviation and amplitude of each gaussian feature, respectively, and take arguments (atom, residue, feature).\n\nThe output mgmm may include the following features:\n\n:Steric (the \"hard center\", a proxy for the repulsive core of Lennard-Jones potentials)\n:Hydrophobe (van der Waals interactions, a proxy for the attractive part of Lennard-Jones potentials)\n:Aromatic (the aromatic ring of phenylalanine, tyrosine, and tryptophan)\n:PosIonizable (the positively charged nitrogen of histidine, arginine, and lysine; histidine gets a fractional charge of +0.1)\n:NegIonizable (the negatively charged oxygen of aspartate and glutamate; each oxygen gets a fractional charge of -0.5)\n:Donor (the hydrogen of a hydrogen bond donor)\n:Acceptor (the oxygen of a hydrogen bond acceptor)\n\n\n\n\n\n","category":"function"},{"location":"#GPCRAnalysis.features_from_structure-Tuple{Any, Real, IntervalSets.AbstractInterval}","page":"Home","title":"GPCRAnalysis.features_from_structure","text":"mgmm = features_from_structure(seq::ChainLike, ρmax::Real, zi::AbstractInterval)\n\nConstruct an IsotropicMultiGMM from seq including all atoms that lie within the cylinder\n\nx^2 + y^2 <= ρmax^2\nz ∈ zi\n\nzi is an AbstractInterval, e.g. 0..30 or -15..15 (see IntervalSets.jl).\n\nThis implicitly assumes that you've aligned seq to the membrane, or aligned seq to a homolog that is membrane-aligned. See align_to_membrane, align.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.filter_long!-Tuple{Any, Real}","page":"Home","title":"GPCRAnalysis.filter_long!","text":"filter_long!(msa, minres::Real)\n\nRemove all sequences from msa with fewer than minres matching residues.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.filter_species!-Tuple{Any, AbstractString}","page":"Home","title":"GPCRAnalysis.filter_species!","text":"filter_species!(msa, speciesname::AbstractString)\n\nRemove all sequences from msa except those with species(sequencename) equal to speciesname.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.forcecomponents","page":"Home","title":"GPCRAnalysis.forcecomponents","text":"forces = forcecomponents(seq, interactions::AbstractVector, residueindexes=eachindex(seq); kwargs...)\n\nCalculate the forces between residues in seq based on the features of each residue and the given interactions, which must be a list of 2-tuples (:field1, :field2) or pairs (:field1, :field2) => coef, where :field1 and :field2 are the names of the features that interact and coef is the coefficient of the force (defaults to 1). The optional keyword arguments kwargs are as described in features_from_structure.\n\nThe feature-names can be the ones used in features_from_structure. Each pair of interactions should be listed, but only in one order (symmetry is automatically enforced). Optionally, you can also \"bundle\" features together: :Ionic is a bundle of :PosIonizable and :NegIonizable, where like charges repel and opposite charges attract with the same magnitude of force. Using (:Ionic,:Ionic) instead of listing all three interactions (:PosIonizable,:PosIonizable, :NegIonizable,:NegIonizable, and :PosIonizable,:NegIonizable) separately ensures that any tuning of ionic forces will satisfy the symmetries of the real world.\n\nUpon return, there is one force-matrix for each residue in seq listed in residueindexes. Each force-matrix is a 3×n matrix where each row corresponds to a force component (x, y, z) and the kth column corresponds to interactions[k].\n\nExamples\n\njulia> seq = getchain(\"1GZM.pdb\")\ninteractions = [(:Steric, :Steric) => 1,           # repulsive\n                (:Hydrophobe, :Hydrophobe) => -1,  # attractive\n                (:Donor, :Acceptor) => -1          # attractive\n                ]\njulia> forces = forcecomponents(seq, interactions)\n\nThe output is a list of 3×4 matrices, one for each residue in seq.\n\nSee also: optimize_weights, forcedict.\n\n\n\n\n\n","category":"function"},{"location":"#GPCRAnalysis.forcedict-Union{Tuple{AbstractArray{Pair{Tuple{K, K}, T}, 1} where T<:Number}, Tuple{K}, Tuple{AbstractArray{Pair{Tuple{K, K}, T}, 1} where T<:Number, AbstractVector}} where K","page":"Home","title":"GPCRAnalysis.forcedict","text":"interactiondict = forcedict(interactions::AbstractVector, w = ones(length(interactions)))\n\nCreate a dictionary of interactions, where interactions[i] should be weighted by w[i].\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.getchain-Tuple{AbstractString}","page":"Home","title":"GPCRAnalysis.getchain","text":"getchain(filename::AbstractString; model=1, chain=\"A\")\n\nRead a PDB or mmCIF file filename and extract the specified chain.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.inward_ecl_residues-Tuple{AbstractVector{<:BioStructures.AbstractResidue}, Any}","page":"Home","title":"GPCRAnalysis.inward_ecl_residues","text":"inward_ecl_residues(seq, eclidxs)\n\nReturn an array of boolean[] indicating which residues (of those specified by eclidxs) are inward-facing (i.e. downward toward the opening of the binding pocket).\n\neclidxs is a vector (with each entry corresponding to an extracellular loop) of ranges of residue indices.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.inward_tm_residues-Tuple{AbstractVector{<:BioStructures.AbstractResidue}, Any}","page":"Home","title":"GPCRAnalysis.inward_tm_residues","text":"inward_tm_residues(seq, tmidxs)\n\nReturn an array of boolean[] indicating which residues (of those specified by tmidxs) are inward-facing.\n\ntmidxs is a vector (typically of length 7, with each entry corresponding to a transmembrane region) of ranges of residue indices.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.isgap","page":"Home","title":"GPCRAnalysis.isgap","text":"isgap(res)\n\nReturn true if the residue res is a gap.\n\n\n\n\n\n","category":"function"},{"location":"#GPCRAnalysis.isunknown","page":"Home","title":"GPCRAnalysis.isunknown","text":"isunknown(res)\n\nReturn true if the residue res is unknown.\n\n\n\n\n\n","category":"function"},{"location":"#GPCRAnalysis.lookupbw-Tuple{Integer, BWScheme}","page":"Home","title":"GPCRAnalysis.lookupbw","text":"helix, residue_position = lookupbw(idx::Integer, scheme::BWScheme)\n\nCalculate the Ballesteros-Weinstein residue number coresponding to residue idx. tmspans describes the transmembrane regions in the reference, and bwconserved the index of the most-conserved residue.\n\nExamples\n\nFor mouse rhodopsin (P15409),\n\njulia> opsd_scheme = BWScheme([55, 83, 135, 161, 215, 267, 303],\n           [34:64, 73:99, 107:139, 150:173, 200:229, 246:277, 285:309]);\n\njulia> lookupbw(160, opsd_scheme)\n(4, 49)\n\njulia> lookupbw((4, 49), opsd_scheme)\n160\n\nThis is the residue just before the most-conserved residue of helix 4.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.map_closest-Tuple{Union{BioStructures.Chain, BioStructures.Model, BioStructures.MolecularStructure, AbstractVector{<:BioStructures.AbstractResidue}}, Union{BioStructures.Chain, BioStructures.Model, BioStructures.MolecularStructure, AbstractVector{<:BioStructures.AbstractResidue}}}","page":"Home","title":"GPCRAnalysis.map_closest","text":"mapping = map_closest(mapto::StructureLike, mapfrom::StructureLike)\n\nReturn a vector mapping[i] = (j, distij), matching the ith residue in mapto to the jth residue in mapfrom and reporting the distance between them. The mapping minimizes the sum of distances. mapto and mapfrom must already be aligned for this to be meaningful.\n\nIf mapfrom is shorter than mapto, some js will be 0, indicating a skipped residue in mapto.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.map_uniprot_retrieve-Tuple{Any}","page":"Home","title":"GPCRAnalysis.map_uniprot_retrieve","text":"result = GPCRAnalysis.map_uniprot_retrieve(jobID)\n\nRetrieve the results of a Uniprot ID mapping job.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.map_uniprot_status-Tuple{Any}","page":"Home","title":"GPCRAnalysis.map_uniprot_status","text":"status = GPCRAnalysis.map_uniprot_status(jobID)\n\nCheck the status of a Uniprot ID mapping job. Returns true if the results are ready. Otherwise, returns the status object.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.map_uniprot_submit","page":"Home","title":"GPCRAnalysis.map_uniprot_submit","text":"jobID = GPCRAnalysis.map_uniprot_submit(ids, from=\"UniProtKB_AC-ID\", to=\"UniProtKB\")\n\nSubmit a list of ids to the Uniprot ID mapping service, to convert from ID convention from to to. The jobID can be used to check the status (map_uniprot_status) and retrieve the results (map_uniprot_retrieve).\n\nExamples\n\njldoctest` julia> jobID = GPCRAnalysis.map_uniprot_submit([\"ENSMUSG00000067064\", \"ENSMUSG00000057464\"], \"Ensembl\");\n\n\n\n\n\n","category":"function"},{"location":"#GPCRAnalysis.marker-Tuple{Integer, AbstractVector{<:Real}, Real, Any}","page":"Home","title":"GPCRAnalysis.marker","text":"str = marker(modelnum, pos, radius, color)\n\nReturn a string that represents a marker in ChimeraX. modelnum is the model number, pos is a 3D position, radius is the radius of the marker, and color is the color of the marker.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.msasequence","page":"Home","title":"GPCRAnalysis.msasequence","text":"seq = msasequence(msa, key)\n\nReturn the aligned sequence corresponding to key.\n\n\n\n\n\n","category":"function"},{"location":"#GPCRAnalysis.optimize_weights-Tuple{AbstractVector{<:AbstractMatrix}}","page":"Home","title":"GPCRAnalysis.optimize_weights","text":"w = optimize_weights(forces)\n\nTune the weights w to approximately satisfy force balance, i.e., solve\n\nmin w.r.t. w  sum(sum(abs2, f*w) for f in forces)\nsubject to    sum(w) == 1, w .>= 0\n\nThis is based on the notion that the protein structure is presumably at an energy minimum.\n\nThis seems to work best for ubiquitous interactions, like :Steric, :Hydrophobe, and hydrogen-bonding. Rarer interactions (:Ionic, :Aromatic) may need to be tuned via different principles.\n\nnote: Note\nThis function requires that you manually load JuMP and HiGHS, e.g., using JuMP, HiGHS.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.pLDDTcolor-Tuple{BioStructures.Residue}","page":"Home","title":"GPCRAnalysis.pLDDTcolor","text":"pLDDTcolor(r::Residue)\npLDDTcolor(score::Real)\n\nReturn the color corresponding to the pLDDT score (a measure of confidence) of a residue.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.percent_similarity","page":"Home","title":"GPCRAnalysis.percent_similarity","text":"pc = percent_similarity(msa)\npc = percent_similarity(f, msa)\n\nCompute the percent similarity between all pairs of sequences in msa. pc[i, j] is the percent similarity between sequences i and j.\n\nOptionally apply mapping function f to each residue before computing similarity.\n\n\n\n\n\n","category":"function"},{"location":"#GPCRAnalysis.project_sequences-Tuple{Any}","page":"Home","title":"GPCRAnalysis.project_sequences","text":"X = project_sequences(msa; fracvar::Real = 0.9)\n\nPerform a classical multidimensional scaling analysis to project the sequences in msa to a space in which pairwise distances approximately reproduce 100 - percentsimilarity(seq1, seq2). The dimensionality is chosen to reconstruction fracvar of the variance.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.query_alphafold_latest-Tuple{AbstractString}","page":"Home","title":"GPCRAnalysis.query_alphafold_latest","text":"url = query_alphafold_latest(uniprotXname; format=\"cif\")\n\nQuery the AlphaFold API for the latest structure of uniprotXname. format should be \"cif\", \"pdb\", or \"bcif\".\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.query_ebi_proteins-Tuple{AbstractString}","page":"Home","title":"GPCRAnalysis.query_ebi_proteins","text":"result = query_ebi_proteins(id; format=:json)\n\nQuery the EBI Proteins API for a protein with the specified id, which must be the Uniprot accession code. You can also supply several proteins as a comma-separated list.\n\nresult is a JSON3 object with many fields.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.query_ncbi-Tuple{Any}","page":"Home","title":"GPCRAnalysis.query_ncbi","text":"result = query_ncbi(id)\n\nQuery the NCBI API for a gene with the specified id, which must be the gene accession code. result is a JSON3 object with many fields.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.query_uniprot_accession-Tuple{Any}","page":"Home","title":"GPCRAnalysis.query_uniprot_accession","text":"accession_code = query_uniprot_accession(id)\n\nPerform a Uniprot search for id, returning the canonical accession code.\n\nExamples\n\njulia> query_uniprot_accession(\"T2R38_MOUSE\")\n\"Q7TQA6\"\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.residue_centroid-Tuple{BioStructures.AbstractResidue}","page":"Home","title":"GPCRAnalysis.residue_centroid","text":"residue_centroid(r::AbstractResidue)\n\nCompute the mean position of all atoms in r excluding hydrogen.\n\nResidue centers may yield a more reliable measure of \"comparable residues\" than the α-carbons (see CAmatrix) because they incorporate the orientation of the side chain relative to the overall fold.\n\nSee also residue_centroid_matrix.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.residue_centroid_matrix-Tuple{Any}","page":"Home","title":"GPCRAnalysis.residue_centroid_matrix","text":"residue_centroid_matrix(seq)\n\nReturn a matrix of all residue centroids as columns. See also residue_centroid.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.residueindex-Tuple{StructAlign, Integer, Nothing}","page":"Home","title":"GPCRAnalysis.residueindex","text":"residueindex(sa::StructAlign, idx1, nothing)\nresidueindex(sa::StructAlign, idx1, nothing, ±1)\n\nCalculate the residue index in structure 2 corresponding to residue idx1 in structure 1. The second form allows you to find the nearest corresponding residue in the forward (+1) or reverse (-1) directions, if idx1 is not among the mapped residues.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.residueindex-Tuple{StructAlign, Nothing, Integer}","page":"Home","title":"GPCRAnalysis.residueindex","text":"residueindex(sa::StructAlign, nothing, idx2)\nresidueindex(sa::StructAlign, nothing, idx2, ±1)\n\nCalculate the residue index in structure 1 corresponding to residue idx2 in structure 2. The second form allows you to find the nearest corresponding residue in the forward (+1) or reverse (-1) directions, if idx2 is not among the mapped residues.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.residuematrix","page":"Home","title":"GPCRAnalysis.residuematrix","text":"R = residuematrix(msa)\n\nGet all residues in the MSA as a matrix, one sequence per row.\n\n\n\n\n\n","category":"function"},{"location":"#GPCRAnalysis.sequenceindexes","page":"Home","title":"GPCRAnalysis.sequenceindexes","text":"idxs = sequenceindexes(msaseq)\nidxs = sequenceindexes(msa, i)\n\nReturn the corresponding index within the full sequence for each position in msaseq. 0 indicates a gap or unknown residue.\n\nThe two-argument form retrieves the sequenceindexes for the ith sequence in msa.\n\n\n\n\n\n","category":"function"},{"location":"#GPCRAnalysis.sequencekeys","page":"Home","title":"GPCRAnalysis.sequencekeys","text":"keys = sequencekeys(msa)\n\nReturn the keys (sequence names) of the MSA.\n\n\n\n\n\n","category":"function"},{"location":"#GPCRAnalysis.sortperm_msa-Tuple{Any}","page":"Home","title":"GPCRAnalysis.sortperm_msa","text":"tour = sortperm_msa(msa)\n\nOrder the sequences in msa to minimize the \"tour length\" visiting each sequence once. The length between sequences is defined at 100 - percentsimilarity(seq1, seq2).\n\nThis can be useful for graphical or alignment display by grouping obviously-similar sequences near one another.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.species-Tuple{AbstractString}","page":"Home","title":"GPCRAnalysis.species","text":"species(name)\n\nExtract the species identifier from a UniProt \"X_Y\" entry or elaborated variant (e.g., PFAM sequence name).\n\nSee also uniprotX.\n\nExamples\n\njulia> species(\"Q8VGW6_MOUSE/31-308\")\n\"MOUSE\"\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.subseqs","page":"Home","title":"GPCRAnalysis.subseqs","text":"msaview = subseqs(msa, rowindexes::AbstractVector{Int})\nmsaview = subseqs(msa, rowmask::AbstractVector{Bool})\n\nsubseqs!(msa, rowindexes::AbstractVector{Int})\nsubseqs!(msa, rowmask::AbstractVector{Bool})\n\nConstruct a reduced-size msaview, keeping only the sequences corresponding to rowindexes/rowmask.\n\n\n\n\n\n","category":"function"},{"location":"#GPCRAnalysis.try_download_alphafold","page":"Home","title":"GPCRAnalysis.try_download_alphafold","text":"try_download_alphafold(uniprotXname, path=alphafoldfilename(uniprotXname); version=4)\n\nAttempt to download an AlphaFold structure. Returns nothing if no entry corresponding to uniprotXname exists; otherwise it returns path, the pathname of the saved file.\n\nIn general, a better approach is to use download_alphafolds for multiple proteins, or query_alphafold_latest combined with Downloads.download for a single protein.\n\n\n\n\n\n","category":"function"},{"location":"#GPCRAnalysis.uniprotX-Tuple{AbstractString}","page":"Home","title":"GPCRAnalysis.uniprotX","text":"uniprotX(name)\n\nExtract the UniProt \"X\" entry from an X_Y entry or elaborated variant (e.g., PFAM sequence name).\n\nSee also species.\n\nExamples\n\njulia> uniprotX(\"Q8VGW6_MOUSE/31-308\")\n\"Q8VGW6\"\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.validate_seq_residues-Tuple{Any, Any}","page":"Home","title":"GPCRAnalysis.validate_seq_residues","text":"validate_seq_residues(msaseq, chain)\n\nReturn true if the residues in msaseq match those in chain, ignoring gaps and unknown residues.\n\n\n\n\n\n","category":"method"},{"location":"#GPCRAnalysis.writechain-Tuple{AbstractString, Union{BioStructures.Chain, AbstractVector{<:BioStructures.AbstractResidue}}}","page":"Home","title":"GPCRAnalysis.writechain","text":"writechain(filename::AbstractString, chain::ChainLike)\n\nWrite the specified chain to a PDB or mmCIF file filename.\n\n\n\n\n\n","category":"method"}]
}
